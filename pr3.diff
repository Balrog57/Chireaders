diff --git a/src/services/ChiReadsScraper.js b/src/services/ChiReadsScraper.js
index 3eebd86..cb963fd 100644
--- a/src/services/ChiReadsScraper.js
+++ b/src/services/ChiReadsScraper.js
@@ -2,6 +2,47 @@ import axios from 'axios';
 import * as cheerio from 'react-native-cheerio';
 
 const BASE_URL = 'https://chireads.com';
+const TIMEOUT = 15000; // 15 seconds timeout
+const MAX_CONTENT_LENGTH = 5 * 1024 * 1024; // 5MB max response size
+const USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36';
+
+// Secure Axios Instance
+const client = axios.create({
+    baseURL: BASE_URL,
+    timeout: TIMEOUT,
+    maxContentLength: MAX_CONTENT_LENGTH,
+    headers: {
+        'User-Agent': USER_AGENT
+    }
+});
+
+/**
+ * Helper to ensure URLs are secure (HTTPS) and belong to the correct domain.
+ * Prevents Open Redirects and Downgrade Attacks.
+ */
+const getSafeUrl = (url) => {
+    if (!url) return null;
+    let safeUrl = url.trim();
+
+    // Handle relative URLs
+    if (!safeUrl.startsWith('http')) {
+        if (!safeUrl.startsWith('/')) safeUrl = '/' + safeUrl;
+        safeUrl = `${BASE_URL}${safeUrl}`;
+    }
+
+    // Enforce HTTPS
+    if (safeUrl.startsWith('http:')) {
+        safeUrl = safeUrl.replace(/^http:/, 'https:');
+    }
+
+    // Domain Check - Ensure we only scrape chireads.com
+    // Robust check: must match BASE_URL exactly OR start with BASE_URL + '/'
+    if (safeUrl !== BASE_URL && !safeUrl.startsWith(`${BASE_URL}/`)) {
+        return null;
+    }
+
+    return safeUrl;
+};
 
 const ChiReadsScraper = {
     /**
@@ -9,13 +50,8 @@ const ChiReadsScraper = {
      */
     getHome: async () => {
         try {
-            const response = await axios.get(BASE_URL, {
-                headers: {
-                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
-                }
-            });
-            console.log('Scraper received HTML length:', response.data.length);
-            console.log('Scraper HTML start:', response.data.substring(0, 100));
+            const response = await client.get('/');
+            // console.log('Scraper received HTML length:', response.data.length);
             const $ = cheerio.load(response.data);
 
             const featured = [];
@@ -27,18 +63,19 @@ const ChiReadsScraper = {
             // Helper to parse a standard book item
             const parseBookItem = (elem, selectorTitle, selectorUrl, selectorImage, selectorDesc = null) => {
                 const title = $(elem).find(selectorTitle).text().trim();
-                const url = $(elem).find(selectorUrl).attr('href');
+                const rawUrl = $(elem).find(selectorUrl).attr('href');
                 const image = $(elem).find(selectorImage).attr('src');
                 const description = selectorDesc ? $(elem).find(selectorDesc).text().trim() : null;
 
-                if (title && url) {
-                    return { title, url, image, description };
+                const safeUrl = getSafeUrl(rawUrl);
+
+                if (title && safeUrl) {
+                    return { title, url: safeUrl, image, description };
                 }
                 return null;
             };
 
-            // 1. En Vedette (Assumption: First .recommended-list, or check for specific container)
-            // L'analyse montre que c'est la premi├¿re liste .recommended-list
+            // 1. En Vedette
             $('.recommended-list').first().find('li').each((i, elem) => {
                 const book = parseBookItem(elem, '.recommended-list-txt a', '.recommended-list-txt a', '.recommended-list-img img');
                 if (book) featured.push(book);
@@ -50,50 +87,47 @@ const ChiReadsScraper = {
                 const chapterLink = $(elem).find('td').eq(1).find('a');
                 const dateLink = $(elem).find('td').eq(3).find('a');
 
-                if (seriesLink.length > 0) {
+                const safeSeriesUrl = getSafeUrl(seriesLink.attr('href'));
+                const safeChapterUrl = getSafeUrl(chapterLink.attr('href'));
+
+                if (seriesLink.length > 0 && safeSeriesUrl) {
                     latest.push({
                         title: seriesLink.text().trim(),
-                        url: seriesLink.attr('href'),
+                        url: safeSeriesUrl,
                         latestChapter: {
                             title: chapterLink.text().trim(),
-                            url: chapterLink.attr('href'),
+                            url: safeChapterUrl, // safeChapterUrl might be null, but usually valid relative
                             date: dateLink.text().trim()
                         }
                     });
                 }
             });
 
-            // 3. Nouvelle Parution (Chercher Header "Nouvelle Parution" -> .news-list)
+            // 3. Nouvelle Parution
             let newsListContainer = null;
             $('.titre-section, h2, h3, div').each((i, elem) => {
                 const txt = $(elem).text().trim();
                 if (txt === 'Nouvelle Parution' || txt.includes('Nouvelle Parution')) {
-                    // Le conteneur .news-list est souvent le fr├¿re ou dans le parent suivant
-                    // D'apr├¿s l'analyse, c'est .news-list
                     newsListContainer = $(elem).next('.news-list');
                     if (newsListContainer.length === 0) {
-                        // Fallback: chercher dans le parent si le header est wrapper
                         newsListContainer = $(elem).parent().find('.news-list');
                     }
                     if (newsListContainer.length === 0) {
-                        // Fallback siblings lookup
                         newsListContainer = $(elem).parent().next().find('.news-list');
-                        if (newsListContainer.length === 0) newsListContainer = $(elem).next(); // Simple next
+                        if (newsListContainer.length === 0) newsListContainer = $(elem).next();
                     }
-                    return false; // Break
+                    return false;
                 }
             });
-            // Fallback general si non trouv├® via header
             if (!newsListContainer || newsListContainer.length === 0) newsListContainer = $('.news-list').first();
 
             newsListContainer.find('li').each((i, elem) => {
-                // Selectors updated based on previous "Original" logic which worked for this class
                 const book = parseBookItem(elem, '.news-list-tit h5 a', '.news-list-tit h5 a', '.news-list-img img', '.news-list-txt');
                 if (book) newReleases.push(book);
             });
 
 
-            // 4. Populaire (Header "Populaire" -> .recommended-list)
+            // 4. Populaire
             $('div.title, h2, h3').each((i, elem) => {
                 if ($(elem).text().trim().includes('Populaire')) {
                     const list = $(elem).next('.recommended-list');
@@ -104,25 +138,17 @@ const ChiReadsScraper = {
                 }
             });
 
-            // 5. Recommand├® (.recommended li)
+            // 5. Recommand├®
             $('.recommended li').each((i, elem) => {
-                // Les s├®lecteurs semblent similaires aux autres listes recommand├®es ?
-                // L'analyse montre: .recommended-list style items
-                // On va tenter les m├¬mes s├®lecteurs g├®n├®riques ou inspecter
-                // Souvent c'est: titre dans a, img dans img.
-                const title = $(elem).find('a').last().text().trim() || $(elem).text().trim(); // Fallback
-                const url = $(elem).find('a').first().attr('href');
+                const rawUrl = $(elem).find('a').first().attr('href');
                 const image = $(elem).find('img').attr('src');
-                // Note: L'analyse montre titre 'Super G├¿ne' etc.
-                // Le markup exact n'est pas 100% visible mais on devine 'a' et 'img'.
-
-                // Am├®lioration bas├®e sur l'exp├®rience Chireads:
-                // .recommended li souvent contient .recommended-img et .recommended-txt
                 let refinedTitle = $(elem).find('.recommended-txt a, .recommended-list-txt a, h3, h4').text().trim();
                 if (!refinedTitle) refinedTitle = $(elem).find('a').last().text().trim();
 
-                if (refinedTitle && url) {
-                    recommended.push({ title: refinedTitle, url, image });
+                const safeUrl = getSafeUrl(rawUrl);
+
+                if (refinedTitle && safeUrl) {
+                    recommended.push({ title: refinedTitle, url: safeUrl, image });
                 }
             });
 
@@ -134,7 +160,7 @@ const ChiReadsScraper = {
                 recommended
             };
         } catch (error) {
-            console.error('Error scraping home:', error);
+            console.error('Error scraping home:', error.message);
             return { featured: [], latest: [], newReleases: [], popular: [], recommended: [] };
         }
     },
@@ -145,45 +171,31 @@ const ChiReadsScraper = {
      */
     getNovelDetails: async (novelUrl) => {
         try {
-            const response = await axios.get(novelUrl);
-            const $ = cheerio.load(response.data);
+            const safeNovelUrl = getSafeUrl(novelUrl);
+            if (!safeNovelUrl) throw new Error('Invalid novel URL');
 
+            const response = await client.get(safeNovelUrl);
+            const $ = cheerio.load(response.data);
 
             const title = $('.inform-title').text().trim();
             const image = $('.inform-product img').attr('src');
-            const author = $('.inform-inform-data h6').text().trim(); // Ou parsing plus fin si besoin
+            const author = $('.inform-inform-data h6').text().trim();
             let description = $('.inform-txt-show span').text().trim();
 
-            // Si description vide, fallback
             if (!description) {
                 description = $('.inform-txt-show').text().trim();
             }
 
             let chapters = [];
-            // Chapter List Logic
-            // Based on debug analysis, chapters are often in .chapitre li, or .volume-content li, or .segment-content li (accordions)
-            // We combine them all.
-            // Chapter List Logic
-            // Fix for missing chapters: Select all 'a' tags inside the list items directly.
-            // The site often puts multiple <a> tags in a single <li> for column layout.
             let chapterLinks = $('.chapitre li a, .volume-content li a, .chapitre-table li a, .segment-content li a');
 
-            // Remove debug logs (or keep minimal if needed)
-            // console.log('Scraper DBG: Items found:', chapterLinks.length);
-
-            // Fix sorting: The site often lists chapters in columns (1, 4, 7... 2, 5, 8...)
             const extractChapterNumber = (title) => {
-                // Modified regex to be stricter and avoid matching "6 nouveaux chapitres..." as chapter 6
-
-                // 1. Keyword match (Chapitre 1, Ch.1, etc.)
                 const keywordMatch = title.match(/(?:chapitre|ch|chapter|no|├®pisode|volume)\.?\s*(\d+(\.\d+)?)/i);
                 if (keywordMatch) return parseFloat(keywordMatch[1]);
 
-                // 2. Starts with specific digits followed by separator (e.g. "1 - Intro", "1. Intro", "1: Intro")
                 const startMatch = title.match(/^\s*(\d+(\.\d+)?)\s*(?:-|:|ÔÇô|\.)\s+/);
                 if (startMatch) return parseFloat(startMatch[1]);
 
-                // 3. Is exactly a number (e.g. "123")
                 const exactNumMatch = title.match(/^\s*(\d+(\.\d+)?)\s*$/);
                 if (exactNumMatch) return parseFloat(exactNumMatch[1]);
 
@@ -193,34 +205,24 @@ const ChiReadsScraper = {
             chapterLinks.each((i, elem) => {
                 const link = $(elem);
                 const chapterTitle = link.text().trim();
-                const chapterUrl = link.attr('href');
+                const rawChapterUrl = link.attr('href');
+                const safeChapterUrl = getSafeUrl(rawChapterUrl);
 
-                if (chapterTitle && chapterUrl) {
+                if (chapterTitle && safeChapterUrl) {
                     chapters.push({
                         title: chapterTitle,
-                        url: chapterUrl,
-                        date: '', // Date often not available in this list view
+                        url: safeChapterUrl,
+                        date: '',
                         number: extractChapterNumber(chapterTitle)
                     });
                 }
             });
 
-            // Reverse if needed (sometimes oldest first) - usually new to old logic applies
-            // Only reverse if user wants oldest first, but standard is newest first for updates, 
-            // oldest first for reading. Usually sites list Oldest -> Newest. 
-            // We'll keep as is (scraped order).
-
-            // Fix absolute URLs
-            chapters = chapters.map(ch => ({
-                ...ch,
-                url: ch.url.startsWith('http') ? ch.url : `${BASE_URL}${ch.url}`
-            }));
-
             chapters.sort((a, b) => {
                 const numA = a.number;
                 const numB = b.number;
                 if (numA !== -1 && numB !== -1) return numA - numB;
-                return 0; // Keep original order if no numbers found
+                return 0;
             });
 
             return {
@@ -231,7 +233,7 @@ const ChiReadsScraper = {
                 chapters
             };
         } catch (error) {
-            console.error('Error scraping details:', error);
+            console.error('Error scraping details:', error.message);
             return null;
         }
     },
@@ -242,7 +244,10 @@ const ChiReadsScraper = {
      */
     getChapterContent: async (chapterUrl) => {
         try {
-            const response = await axios.get(chapterUrl);
+            const safeChapterUrl = getSafeUrl(chapterUrl);
+            if (!safeChapterUrl) throw new Error('Invalid chapter URL');
+
+            const response = await client.get(safeChapterUrl);
             const $ = cheerio.load(response.data);
 
             const title = $('.article-title').text().trim();
@@ -250,28 +255,24 @@ const ChiReadsScraper = {
             const paragraphs = [];
             $('#content p').each((i, elem) => {
                 const text = $(elem).text().trim();
-                // Avoid empty lines if possible
                 if (text) paragraphs.push(text);
             });
 
-            // Navigation (Chapitre pr├®c├®dent / suivant)
-            // Utilisation des index fixes observ├®s: 0 = Prev, 2 = Next
             const navLinks = $('.article-function').first().find('a');
-            let prevUrl = navLinks.eq(0).attr('href');
-            let nextUrl = navLinks.eq(2).attr('href');
+            let prevUrlRaw = navLinks.eq(0).attr('href');
+            let nextUrlRaw = navLinks.eq(2).attr('href');
 
-            // Si prevUrl est "#", c'est qu'il n'y a pas de chapitre pr├®c├®dent
-            if (prevUrl === '#') prevUrl = null;
+            if (prevUrlRaw === '#') prevUrlRaw = null;
 
             return {
                 title,
                 content: paragraphs,
-                html: $('#content').html(),
-                prevUrl,
-                nextUrl
+                // html: removed to prevent XSS risk if used improperly
+                prevUrl: getSafeUrl(prevUrlRaw),
+                nextUrl: getSafeUrl(nextUrlRaw)
             };
         } catch (error) {
-            console.error('Error scraping chapter:', error);
+            console.error('Error scraping chapter:', error.message);
             return null;
         }
     },
@@ -282,39 +283,32 @@ const ChiReadsScraper = {
      */
     search: async (query) => {
         try {
-            const searchUrl = `${BASE_URL}/?s=${encodeURIComponent(query)}`;
-            const response = await axios.get(searchUrl, {
-                headers: {
-                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
-                }
-            });
+            const searchUrl = `/?s=${encodeURIComponent(query)}`;
+            const response = await client.get(searchUrl);
             const $ = cheerio.load(response.data);
             const books = [];
 
-            // Architecture de recherche souvent similaire aux cat├®gories
             $('.news-list li, .search-list li, .main-col li').each((i, elem) => {
                 const titleElem = $(elem).find('.news-list-tit h5 a, h2 a, h3 a, .entry-title a').first();
                 const title = titleElem.text().trim();
-                const url = titleElem.attr('href') || $(elem).find('a').first().attr('href');
+                const rawUrl = titleElem.attr('href') || $(elem).find('a').first().attr('href');
                 const image = $(elem).find('img').first().attr('src');
                 const description = $(elem).find('.news-list-txt, .entry-content').text().trim();
 
-                // Filtrage basique pour ├®viter les r├®sultats vides
-                if (title && url && !url.includes('/chapitre-')) { // Exclure les chapitres individuels si possible
-                    books.push({ title, url, image, description });
+                const safeUrl = getSafeUrl(rawUrl);
+
+                if (title && safeUrl && !safeUrl.includes('/chapitre-')) {
+                    books.push({ title, url: safeUrl, image, description });
                 }
             });
 
-            // Filter results to strictly match the title as requested by user
             const filteredBooks = books.filter(book =>
                 book.title.toLowerCase().includes(query.toLowerCase())
             );
 
-
-
             return filteredBooks;
         } catch (error) {
-            console.error('Error searching:', error);
+            console.error('Error searching:', error.message);
             return [];
         }
     },
@@ -326,45 +320,34 @@ const ChiReadsScraper = {
      */
     getAllBooks: async (page = 1, category = 'translatedtales') => {
         try {
-            const url = `${BASE_URL}/category/${category}/page/${page}/`;
-            const response = await axios.get(url, {
-                headers: {
-                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
-                }
-            });
+            const url = `/category/${category}/page/${page}/`;
+            const response = await client.get(url);
             const $ = cheerio.load(response.data);
 
             const books = [];
 
-            // Updated selector based on deep analysis (same as news-list items)
-            // 'article' was wrong. It is likely a standard .news-list or similar structure.
-            // Analysis showed images inside div.news-list-img inside li.
-            // So we select keys based on that.
-
-            // Check for list items regardless of container class if specific class fails, 
-            // but .news-list li is the strong candidate.
             let items = $('.news-list li');
-
-            // Defines fallback if .news-list is not found directly (e.g. if it uses a different wrapper)
             if (items.length === 0) {
-                items = $('.main-col li'); // Fallback to main column list items
+                items = $('.main-col li');
             }
 
             items.each((i, elem) => {
                 const titleElem = $(elem).find('.news-list-tit h5 a, h2 a, h3 a, .entry-title a').first();
                 const title = titleElem.text().trim();
-                const url = titleElem.attr('href') || $(elem).find('a').first().attr('href');
+                const rawUrl = titleElem.attr('href') || $(elem).find('a').first().attr('href');
                 const image = $(elem).find('.news-list-img img, img').first().attr('src');
                 const description = $(elem).find('.news-list-txt, .entry-content').text().trim();
 
-                if (title && url) {
-                    books.push({ title, url, image, description });
+                const safeUrl = getSafeUrl(rawUrl);
+
+                if (title && safeUrl) {
+                    books.push({ title, url: safeUrl, image, description });
                 }
             });
 
             return books;
         } catch (error) {
-            console.error(`Error scraping library (${category}):`, error);
+            console.error(`Error scraping library (${category}):`, error.message);
             return [];
         }
     }
